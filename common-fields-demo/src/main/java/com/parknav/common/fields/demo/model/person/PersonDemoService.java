package com.parknav.common.fields.demo.model.person;

import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Consumer;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import com.parknav.common.fields.FieldGraph;
import com.parknav.common.fields.demo.model.boat.Boat;
import com.parknav.common.fields.demo.model.boat.BoatDemoService;
import com.parknav.common.fields.demo.model.boat.BoatService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.parknav.common.fields.demo.model.person.PersonDemoData.Record;

/** Operates on sample persons from memory store */
public class PersonDemoService implements PersonService {

	@Override
	public Person get(String id, FieldGraph<Person.Field> graph) {

		// NOTE: if this was SQL service, here we would build SELECT statement with only selected columns

		Record rec = PersonDemoData.$().parallelStream().filter(r -> id.equals(r.id)).findFirst().orElse(null);
		
		if (rec == null)
			return null;
		
		return read(rec, graph);
		
	}

	@Override
	public void create(Person person, FieldGraph<Person.Field> graph) {
		
		// NOTE: if this was SQL service, here we would build INSERT statement, executed it and read autogenerated columns
		person.setId(UUID.randomUUID().toString());
		
		PersonDemoData.$().add(new Record(
			person.getId(),
			person.getName(),
			person.getEmail(),
			person.getPermissions(),
			Optional.ofNullable(person.getBoat()).map(Boat::getId).orElse(null)
		));
		
		Log.debug("Created person: {}", person);
		
	}

	@Override
	public void modify(Person person, Person patch, FieldGraph<Person.Field> graph) {

		AtomicBoolean hasUpdates = new AtomicBoolean(false);
		
		// NOTE: if this was SQL service, here we would build UPDATE statement with only selected columns
		List<Consumer<Record>> modifiers = patch.getFields().stream()
			.map(field -> {
				switch (field) {
					case name: return (Consumer<Record>) (r -> r.name = person.getName());
					case email: return null;	// let's assume email is not updatable
					case permissions: return (Consumer<Record>) r -> r.permissions = new HashSet<>(person.getPermissions());
					case boat: return (Consumer<Record>) (r -> r.boatId = Optional.ofNullable(person.getBoat()).map(Boat::getId).orElse(null));
				}
				throw new UnsupportedOperationException("Unknown person field: " + field);
			})
			.filter(Objects::nonNull)
			.filter(modifier -> { hasUpdates.set(true); return true; })
			.collect(Collectors.toList());
		
		// if no updatable fields were used, bail out
		if (!hasUpdates.get()) {
			person.extend(graph, this);
			return;
		}

		// NOTE: if this was SQL service, here we would execute statement
		Record rec = PersonDemoData.$().parallelStream().filter(r -> person.getId().equals(r.id)).findFirst().orElse(null);
		if (rec == null)
			throw new IllegalArgumentException("Person " + person + " doesn't exist!");
		modifiers.forEach(modifier -> modifier.accept(rec));

		// lets assume modifiers didn't touch any fields outside of their own
		person.clearFields(graph);
		person.extend(graph, this);

		Log.debug("Modified {} field(s) in person {}", modifiers.size(), person);
		
	}

	@Override
	public void delete(Person person) {

		PersonDemoData.$().removeIf(rec -> rec.id.equals(person.getId()));
	
		Log.debug("Deleted person: {}", person);

	}

	@Override
	public int count(Void selector) {
		throw new UnsupportedOperationException("Outside of scope of this demo");
	}

	@Override
	public Stream<Person> query(Void selector, FieldGraph<Person.Field> graph) {
		throw new UnsupportedOperationException("Outside of scope of this demo");
	}

	@Override
	public Stream<Person> queryAllFieldValues(Void selector, Set<Person.Field> fields) {
		throw new UnsupportedOperationException("Outside of scope of this demo");
	}

	private Person read(Record record, FieldGraph<Person.Field> graph) {

		BoatService boatService = new BoatDemoService();
		
		// if this was SQL service, here we would (selectively) read java.sql.ResultSet
		
		Person person = new Person();

		person.setId(record.id);
		
		for (Person.Field field : graph)
			switch (field) {
				case name: person.setName(record.name); break;
				case email: person.setEmail(record.email); break;
				case permissions: person.setPermissions(new HashSet<>(record.permissions)); break;
				case boat: person.setBoat(Optional.ofNullable(record.boatId).map(id -> boatService.get(id, graph.getGraph(field, Boat.Field.class))).orElse(null)); break;
			}

		return person;
		
	}

	private static final Logger Log = LoggerFactory.getLogger(PersonDemoService.class);

}
