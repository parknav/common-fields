package com.steatoda.commons.fields.demo.model.boat;

import java.util.EnumSet;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Consumer;
import java.util.stream.Collectors;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.common.collect.Sets;

import com.steatoda.commons.fields.FieldGraph;
import com.steatoda.commons.fields.FieldUnavailableException;
import com.steatoda.commons.fields.demo.model.boat.BoatDemoData.Record;
import com.steatoda.commons.fields.demo.model.marina.Marina;
import com.steatoda.commons.fields.demo.model.marina.MarinaDemoService;
import com.steatoda.commons.fields.demo.model.marina.MarinaService;
import com.steatoda.commons.fields.demo.model.person.Person;
import com.steatoda.commons.fields.demo.model.person.PersonDemoService;
import com.steatoda.commons.fields.demo.model.person.PersonService;

/** Operates on sample boats from memory store */
public class BoatDemoService implements BoatService {

	@Override
	public Boat get(String id, FieldGraph<Boat.Field> fields) {

		if (fields.isEmpty())
			return Boat.ref(id);
		
		// NOTE: if this was SQL service, here we would build SELECT statement with only selected columns

		Record rec = BoatDemoData.$().parallelStream().filter(r -> id.equals(r.id)).findFirst().orElse(null);
		
		if (rec == null)
			return null;
		
		return read(rec, fields);
		
	}

	@Override
	public void create(Boat boat) {
		
		Set<Boat.Field> missingFields = Sets.difference(boat.getFields(), EnumSet.allOf(Boat.Field.class));
		if (!missingFields.isEmpty())
			throw new FieldUnavailableException(missingFields);
		
		// NOTE: if this was SQL service, here we would build INSERT statement, executed it and read autogenerated columns
		boat.setId(UUID.randomUUID().toString());
		
		BoatDemoData.$().add(new Record(
			boat.getId(),
			boat.getName(),
			boat.getType(),
			Optional.ofNullable(boat.getHomeport()).map(Marina::getId).orElse(null),
			Optional.ofNullable(boat.getSkipper()).map(Person::getId).orElse(null),
			boat.getCrew().stream().map(Person::getId).collect(Collectors.toList())
		));
		
		Log.debug("Created boat: {}", boat);
		
	}

	@Override
	public void modify(Boat boat, Set<Boat.Field> fields) {

		AtomicBoolean hasUpdates = new AtomicBoolean(false);
		
		// NOTE: if this was SQL service, here we would build UPDATE statement with only selected columns
		List<Consumer<Record>> dummyModifiers = fields.stream()
			.map(field -> {
				switch (field) {
					case name: return (Consumer<Record>) (r -> r.name = boat.getName());
					case type: return (Consumer<Record>) (r -> r.type = boat.getType());
					case homeport: return (Consumer<Record>) (r -> r.homeportId = Optional.ofNullable(boat.getHomeport()).map(Marina::getId).orElse(null));
					case skipper: return (Consumer<Record>) (r -> r.skipperId = Optional.ofNullable(boat.getSkipper()).map(Person::getId).orElse(null));
					case crew: return (Consumer<Record>) r -> r.crewIds = boat.getCrew().stream().map(Person::getId).collect(Collectors.toList());
				}
				throw new UnsupportedOperationException("Unknown boat field: " + field);
			})
			.filter(Objects::nonNull)
			.filter(modifier -> { hasUpdates.set(true); return true; })
			.collect(Collectors.toList());
		
		// if no updatable fields were used, bail out
		if (!hasUpdates.get())
			return;

		// NOTE: if this was SQL service, here we would execute statement
		Record rec = BoatDemoData.$().parallelStream().filter(r -> boat.getId().equals(r.id)).findFirst().orElse(null);
		if (rec == null)
			throw new IllegalArgumentException("Boat " + boat + " doesn't exist!");
		dummyModifiers.forEach(modifier -> modifier.accept(rec));
		
		Log.debug("Modified {} field(s) in boat {}", dummyModifiers.size(), boat);
		
	}

	@Override
	public void delete(Boat boat) {
		
		BoatDemoData.$().removeIf(rec -> rec.id.equals(boat.getId()));
	
		Log.debug("Deleted boat: {}", boat);

	}

	private Boat read(Record record, FieldGraph<Boat.Field> fields) {

		MarinaService marinaService = new MarinaDemoService();
		PersonService personService = new PersonDemoService();
		
		// if this was SQL service, here we would (selectively) read java.sql.ResultSet
		
		Boat boat = new Boat();

		boat.setId(record.id);
		
		for (Boat.Field field : fields)
			switch (field) {
				case name: boat.setName(record.name); break;
				case type: boat.setType(record.type); break;
				case homeport: boat.setHomeport(marinaService.get(record.homeportId, fields.getGraph(field, Marina.Field.class))); break;
				case skipper: boat.setSkipper(personService.get(record.skipperId, fields.getGraph(field, Person.Field.class))); break;
				case crew: boat.setCrew(record.crewIds.stream().map(id -> personService.get(id, fields.getGraph(field, Person.Field.class))).collect(Collectors.toList()));
			}

		return boat;
		
	}

	private static final Logger Log = LoggerFactory.getLogger(BoatDemoService.class);

}
